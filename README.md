# Estructura_LinkedLists 
### Carpetas :file_folder:
+ Java_LinkedLists :red_circle:
    + Circular: Main de ejercicios circulares
    + Ejercicios/Test_LinkedL: Main de ejercicios simples
    + Nodo/Nodo2: clase Nodo tradicional y Nodo polinómico
    + LinkedList/LinkelistC: lista simple y circular con sus metodos que resuelven los ejericios
+ Python_LinkedLists :snake:
    + Circular: idem
    + Linked_main: idem
    + Linkedlist/LinkedlistC
    + Nodo: contiene Nodos y Nodos polinómicos
### Listas simples  :arrow_right:
 1.	Dadas dos listas simples enlazadas ya creadas cuyos inicios son PTR1 y PTR2, hacer un algoritmo que elimine de la lista PTR1 los elementos en común entre las dos listas. Nota: No se puede asumir que las listas están ordenadas.  

2.	Hacer un algoritmo que escriba el número total de elementos diferentes en una lista enlazada ya creada con respecto a otra*¿Cuáles son? 

3.	Hacer un algoritmo que dada una lista simple enlazada ya creada, invierta su sentido. (no puede cambiar la información, solo los enlaces). 

4.	Hacer un algoritmo que realice las siguientes operaciones a medida que recorre una lista:
a.	Si la información del nodo es negativa insertar un nuevo nodo antes de este con información igual a -1000
b.	Si la información del nodo es positiva insertar un nuevo nodo después de este con información igual a 1000
c.	Si la información del nodo es cero eliminarlo.
 
    No se permite recorrer la lista más de una vez. 	

5.	Hacer un algoritmo que regrese cuantos elementos de una lista no se repiten.


6.	Dada una lista enlazada simple ya creada, hacer un algoritmo que vaya formando dos listas (PTR1 y PTR2) con los mismos nodos de la lista inicial de tal forma que en la lista PTR1 vayan quedando todos los elementos positivos, y en la lista PTR2 todos los elementos negativos. Si hay nodos que tengan como información el 0 se eliminan. 

7.	Dadas dos listas enlazadas simples ya creadas (PTR1 y PTR2) ordenadas ascendentemente, hacer un algoritmo que cree una tercera lista PTR3 ordenada descendentemente con los elementos comunes de las dos listas.

8.	Eliminar el K-ésimo nodo de una lista simple enlazada. 

9.	Escribir un algoritmo que verifique si dos listas simples son semejantes. Dos listas enlazadas son semejantes si tienen los mismos elementos, no importa el orden. Si un elemento se repite en una lista en la otra debe repetirse igual número de veces

### Listas Circulares :white_circle:
1.	Recorrer una lista circular ya creada. 
2.	Eliminar un nodo de una lista circular ya creada.  
3.	Agregar un nodo antes de uno que esté en una lista circular ya creada. 
4.	Crear una lista circular. 
5.	Dadas dos listas circulares ya creadas PTR1 y PTR2, hacer un algoritmo que inserte los elementos de PTR2 a PTR1. Posibles formas:
a.	De manera ordenada (Puede asumir no repetidos) 
b.	Indicando una posición inicial en PTR1 donde después ó antes de esta vamos a insertar todos los elementos de PTR2. 
6.	Hacer un algoritmo que dadas dos listas enlazadas circulares PTR1 y PTR2, las cuales representan dos polinomios (Puede asumir que ya están ordenados de manera descendente), sume los polinomios dejando la respuesta en PTR1.

Ejercicios Adicionales (En java):
+ ordenamiento burbuja en enlaces de lista enlazada simple :skull:
+ Dadas dos listas enlazadas circulares ya creadas (PTR1, PTR2).
Hacer un algoritmo que elimine de la lista PTR1, todas las secuencias de
elementos iguales de las lista PTR2 que se encuentren en PTR1 :brain:
